local Storage = game:GetService("ReplicatedStorage")
local Server = game:GetService("ServerScriptService")

local Directory = Server.Storage
local Chess = Directory.Chess
local Arbiter = Chess.Arbiter

local Dependencies = Storage.Dependencies
local Packages = Storage.Packages

local Parameters = Dependencies.Parameters

local Knit = require(Packages.Knit)

local Schema = require(Arbiter.Schema)

local Utilities = require(Dependencies.Utilities)
local Resources = require(Dependencies.Resources)

local Configuration = require(Parameters.Configuration)

local Service = Knit.CreateService({
	Name = "Registry",

	Client = {
		Disconnect = Knit.CreateSignal(),
	},

	Cache = setmetatable({}, {
		__index = function(self, Identifier)
			local State = rawget(self, Identifier)

			if State ~= nil then
				return State
			end

			local Value = Resources.AccessOngoingInstance(Identifier)

			rawset(self, Identifier, Value)

			return Resources.AccessOngoingInstance(Identifier)
		end,
	}),
})

local Client = Service.Client
local Cache = Service.Cache

-- Verifies the selected piece matches the identifier associated with the chessboard.

function Client:CheckAvailability(Contender, Piece, Square)
	local Row, Column = Resources.Unpack(Square)

	local Coordinates = Piece:GetAttribute("Coordinates")

	local Name = Piece:GetAttribute("Piece")
	local Identifier = Piece:GetAttribute("Identifier")

	local Content = Cache[Identifier] or Resources.AccessOngoingInstance(Identifier)

	assert(Content, "No existing match contents present.")

	local Chessboard = Content.Board
	local Actor = Content.Actor

	-- Validate that the specified row exists in the board's storage table

	if not Content.Storage[Row] then
		return warn("The specified coordinates are invalid or reference a non-existent board position.")
	end

	if Contender.UserId ~= Actor.UserId then
		return warn("Contender marked as inactive for the current turn cycle.")
	end

	Content.Actor = Resources.Switch(Content.Switching, Actor)

	-- Switches the active actor to the opposing contender

	local Path = Client[Name](Client, Contender, Piece)
	local Route = Service:Compute(Path, Chessboard)

	-- Verify that the intended square is part of the computed valid movement path

	if not table.find(Route, Square) then
		return warn("Square is not part of the authorized path generated by the algorithm.")
	end

	local X, Y = Coordinates.Scale, Coordinates.Offset
	local Log = Resources.Record(Piece, Square)

	-- Check whether a piece already exists in the targeted square

	if Content.Storage[Row][Column] then
		local Object = Content.Storage[Row][Column]

		Object:SetAttribute("State", "Capture")

		Log.Capture = Resources.Capture(Object)

		-- Animates the Object's Transparency Instance.

		Utilities.Animate(Object, Configuration.Movement, {
			Transparency = 1,
		}):Play()

		-- Remove the existing piece instance from the board entirely

		task.delay(Configuration.Delay.Medium, Object.Destroy, Object)
	end

	table.insert(Content.History, Log)

	-- Update the piece's location in the board's storage structure

	Content.Storage[Row][Column] = Piece

	-- Encode the new coordinates into a UDim and assign it to the piece's attributes

	Piece:SetAttribute("Coordinates", Log.To)

	-- Makes sure to set the "HasMoved" attribute as on

	if not Piece:GetAttribute("HasMoved") then
		Piece:SetAttribute("HasMoved", true)
	end

	local Scale, Offset = Coordinates.Scale, Coordinates.Offset

	Content.Storage[Scale][Offset] = nil

	-- Update the piece's position in the 3D world to reflect the new board state

	Utilities.Animate(Piece, Configuration.Movement, {
		Position = Resources.GetSquareVector(Square, Chessboard).Position + Vector3.yAxis * (Piece.Size.Y / 2),
	}):Play()

	-- Notify the client of a successful move (or trigger any client-side disconnection logic)

	return Client.Disconnect:Fire(Contender)
end

function Client:Rook(Contender, Piece)
	local Coordinates = Piece:GetAttribute("Coordinates")

	local Colour = Piece:GetAttribute("Colour")
	local Identifier = Piece:GetAttribute("Identifier")

	local Content = Cache[Identifier] or Resources.AccessOngoingInstance(Identifier)

	-- Column refers to the vertical columns, while Rows refers to the horizontal rows.

	local Rows, Column = Coordinates.Scale, Coordinates.Offset

	local Offsets = {
		Vertical = {
			Up = { X = 0, Y = 1 }, -- Forwards
			Down = { X = 0, Y = -1 }, -- Backwards
		},

		Horizontal = {
			Right = { X = 1, Y = 0 }, -- Right
			Left = { X = -1, Y = 0 }, -- Left
		},
	}

	local Route = Utilities.CloneDictionary(Schema.Trajectory)

	for Path, Direction in Offsets do
		-- Step through a maximum of 7 tiles in that direction (standard chessboard)

		for Name, Offset in Direction do
			for Step = 1, 7, 1 do
				local X = Rows + Offset.X * Step
				local Y = Column + Offset.Y * Step

				if not Content.Storage[X] then
					break
				end

				local Occupant = Content.Storage[X][Y]

				if Content.Storage[X][Y] then
					-- Stop completely if it's an ally (cannot move or capture)

					if Occupant:GetAttribute("Colour") ~= Colour then
						table.insert(Route[Path], { Row = X, Column = Y })
					end

					break
				end

				-- Add the empty square to the route

				table.insert(Route[Path], { Row = X, Column = Y })
			end
		end
	end

	return Service.Filter(Route, workspace.Matches[Identifier])
end

-- Computes the available path for a pawn piece based on its coordinates and attributes

function Client:Pawn(Contender, Piece)
	local Coordinates = Piece:GetAttribute("Coordinates")

	local Colour = Piece:GetAttribute("Colour")
	local HasMoved = Piece:GetAttribute("HasMoved")
	local Direction = Piece:GetAttribute("Direction")
	local Identifier = Piece:GetAttribute("Identifier")

	local Content = Cache[Identifier] or Resources.AccessOngoingInstance(Identifier)
	local Rows, Column = Coordinates.Scale, Coordinates.Offset

	local Route = Utilities.CloneDictionary(Schema.Trajectory)

	if not Content.Storage[Rows][Column + Direction] then
		table.insert(Route.Vertical, { Row = Rows, Column = Column + Direction })
	end

	-- Checks whether the piece has been already moved before adding double forwards.

	if not HasMoved then
		if not Content.Storage[Rows][Column + (Direction * 2)] then
			table.insert(Route.Vertical, { Row = Rows, Column = Column + (Direction * 2) })
		end
	end

	if Content.Storage[Rows - Direction] then
		-- Checks whether a piece exists on the left diagonal relative to the xAxis, yAxis

		local xAxis, yAxis = Rows - Direction, Column + Direction

		if Content.Storage[Rows - Direction][Column + Direction] then
			local Occupant = Content.Storage[xAxis][yAxis]

			if Occupant:GetAttribute("Colour") ~= Colour then
				table.insert(Route.Horizontal, { Row = xAxis, Column = yAxis })
			end
		end
	end

	if Content.Storage[Rows + Direction] then
		-- Checks whether a piece exists on the right diagonal relative to the xAxis, yAxis.

		local xAxis, yAxis = Rows + Direction, Column + Direction

		if Content.Storage[Rows + Direction][Column + Direction] then
			local Occupant = Content.Storage[Rows + Direction][Column + Direction]

			if Occupant:GetAttribute("Colour") ~= Colour then
				table.insert(Route.Horizontal, { Row = xAxis, Column = yAxis })
			end
		end
	end

	--TODO: Add en-passant captures ability & pawn promotion

	return Service.Filter(Route, workspace.Matches[Identifier])
end

-- Computes the available path for a pawn piece based on its coordinates and attributes

function Client:Bishop(Contender, Piece)
	local Route = Utilities.CloneDictionary(Schema.Trajectory)

	local Colour = Piece:GetAttribute("Colour")
	local Identifier = Piece:GetAttribute("Identifier")
	local Coordinates = Piece:GetAttribute("Coordinates")

	local Content = Cache[Identifier] or Resources.AccessOngoingInstance(Identifier)

	local Row, Column = Coordinates.Scale, Coordinates.Offset

	local Offsets = {
		Right = {
			Up = { X = 1, Y = 1 }, -- Right-up
			Down = { X = 1, Y = -1 }, -- Right-down
		},

		Left = {
			Up = { X = -1, Y = 1 }, -- Left-up
			Down = { X = -1, Y = -1 }, -- Left-down
		},
	}

	for Name, Direction in Offsets do
		for Path, Offset in Direction do
			for Step = 1, 7, 1 do
				local X = Offset.X * Step
				local Y = Offset.Y * Step

				-- Skips any rows that are outside the board boundaries

				if not Content.Storage[X + Row] then
					continue
				end

				if not Content.Storage[X + Row][Column + Y] then
					table.insert(Route[Name], { Row = X + Row, Column = Y + Column })
				elseif Content.Storage[X + Row][Column + Y] then
					local Occupant = Content.Storage[X + Row][Column + Y]

					-- Appends enemy-occupied squares as valid capture targets

					if Occupant:GetAttribute("Colour") ~= Colour then
						table.insert(Route[Name], { Row = X + Row, Column = Y + Column })
					end

					-- Ends path traversal after encountering any occupant

					break
				end
			end

			-- Completes traversal for the current diagonal direction
		end
	end

	return Service.Filter(Route, workspace.Matches[Identifier])
end

-- Computes the available path for a Knight piece based on its coordinates and attributes

function Client:Knight(Contender, Piece)
	local Route = Utilities.CloneDictionary(Schema.Trajectory)

	local Colour = Piece:GetAttribute("Colour")
	local Identifier = Piece:GetAttribute("Identifier")
	local Coordinates = Piece:GetAttribute("Coordinates")

	local Content = Resources.AccessOngoingInstance(Identifier)

	local Row, Column = Coordinates.Scale, Coordinates.Offset

	local Offsets = {
		Right = {
			Up = { X = 1, Y = 2 }, -- Right-up
			Down = { X = 1, Y = -2 }, -- Right-down

			Left = { X = 2, Y = 1 },
			Right = { X = 2, Y = -1 },
		},

		Left = {
			Up = { X = -1, Y = 2 }, -- Left-up
			Down = { X = -1, Y = -2 }, -- Left-down

			Left = { X = -2, Y = -1 }, -- Left-left
			Right = { X = -2, Y = 1 },
		},
	}

	for Name, Direction in Offsets do
		-- Iterate through each L-shaped offset

		for Path, Offset in Direction do
			local X, Y = Offset.X, Offset.Y

			-- Skips any invalid rows that are outside the board boundaries

			if not Content.Storage[X + Row] then
				continue
			end

			-- Adds the square after verifying that it's empty.

			if not Content.Storage[X + Row][Column + Y] then
				table.insert(Route[Name], { Row = X + Row, Column = Y + Column })
			elseif Content.Storage[X + Row][Column + Y] then
				local Occupant = Content.Storage[X + Row][Column + Y]

				-- Capture enemy piece only (allies are ignored)

				if Occupant:GetAttribute("Colour") ~= Colour then
					table.insert(Route[Name], { Row = X + Row, Column = Y + Column })
				end
			end

			-- No break here — Knights don’t scan beyond pieces.
		end
	end

	return Service.Filter(Route, workspace.Matches[Identifier])
end

-- Computes the available path for a pawn piece based on its coordinates and attributes

function Client:Queen(Contender, Piece)
	local Route = Utilities.CloneDictionary(Schema.Trajectory)

	local Colour = Piece:GetAttribute("Colour")
	local Identifier = Piece:GetAttribute("Identifier")
	local Coordinates = Piece:GetAttribute("Coordinates")

	local Content = Resources.AccessOngoingInstance(Identifier)

	local Row, Column = Coordinates.Scale, Coordinates.Offset

	local Offsets = {
		Horizontal = {
			{ X = 1, Y = 0 },
			{ X = -1, Y = 0 },
		}, -- Down, Up

		Vertical = {
			{ X = 0, Y = 1 },
			{ X = 0, Y = -1 },
		}, -- Right, Left

		Right = {
			Up = { X = 1, Y = 1 }, -- Right-up
			Down = { X = 1, Y = -1 }, -- Right-down
		},

		Left = {
			Up = { X = -1, Y = 1 }, -- Left-up
			Down = { X = -1, Y = -1 }, -- Left-down
		},
	}

	for Name, Direction in Offsets do
		for Path, Offset in Direction do
			for Step = 1, 7, 1 do
				local X = Offset.X * Step
				local Y = Offset.Y * Step

				-- Skips invalid rows that are outside the board boundaries

				if not Content.Storage[X + Row] then
					continue
				end

				-- Inserts empty board squares into the movement route

				if not Content.Storage[X + Row][Column + Y] then
					table.insert(Route[Name], { Row = X + Row, Column = Y + Column })
				elseif Content.Storage[X + Row][Column + Y] then
					local Occupant = Content.Storage[X + Row][Column + Y]

					-- Appends enemy-occupied squares as valid capture targets

					if Occupant:GetAttribute("Colour") ~= Colour then
						table.insert(Route[Name], { Row = X + Row, Column = Y + Column })
					end

					-- Ends path traversal after encountering any occupant

					break
				end
			end

			-- Completes traversal for the current diagonal direction
		end
	end

	return Service.Filter(Route, workspace.Matches[Identifier])
end

-- Computes the available path for a pawn piece based on its coordinates and attributes

function Client:King(Contender, Piece)
	local Route = Utilities.CloneDictionary(Schema.Trajectory)

	local Coordinates = Piece:GetAttribute("Coordinates")
	local Identifier = Piece:GetAttribute("Identifier")
	local Colour = Piece:GetAttribute("Colour")

	local Content = Resources.AccessOngoingInstance(Identifier)
	local Row, Column = Coordinates.Scale, Coordinates.Offset

	local Offsets = {
		Horizontal = {
			{ X = 1, Y = 0 },
			{ X = -1, Y = 0 },
		}, -- Down, Up

		Vertical = {
			{ X = 0, Y = 1 },
			{ X = 0, Y = -1 },
		}, -- Right, Left

		Right = {
			{ X = 1, Y = 1 },
			{ X = -1, Y = 1 },
		}, -- Down-right, Down-left

		Left = {
			{ X = 1, Y = -1 },
			{ X = -1, Y = -1 },
		}, -- Up-right, Up-left
	}

	for Name, Offset in Offsets do
		for Position, Direction in Offset do
			local X, Y = Direction.X, Direction.Y

			if not Content.Storage[X + Row] then
				continue
			end

			if not Content.Storage[X + Row][Column + Y] then
				table.insert(Route[Name], { Row = X + Row, Column = Y + Column })
			end

			if Content.Storage[X + Row][Column + Y] then
				local Occupant = Content.Storage[X + Row][Column + Y]

				if Occupant:GetAttribute("Colour") ~= Colour then
					table.insert(Route[Name], { Row = X + Row, Column = Y + Column })
				end
			end

			-- Stops scanning in this direction after encountering a piece (cannot jump over pieces).
		end
	end

	--TODO: Implement logic for castling, including king and rook movement validation, path clearance checks, and move execution.

	return Service.Filter(Route, workspace.Matches[Identifier])
end

-- Transforms coordinate-based trajectory paths into square instances on the board

function Service:Compute(Route, Chessboard)
	local Filter = {}

	-- Convert the coordinate into a square instance and assign it under the direction's key

	for Name, Direction in Route do
		for Position, Coordinates in Direction do
			local X, Y = Coordinates.Row, Coordinates.Column

			table.insert(Filter, Resources:Convert({ Row = X, Column = Y }, Chessboard))
		end
	end

	-- Returns the dictionary containing square instances per movement direction

	return Filter
end

-- Filters out invalid squares from the given movement trajectory.

function Service.Filter(Trajectory, Chessboard)
	local Filter = {}

	for Name, Direction in Trajectory do
		if not Filter[Name] then
			Filter[Name] = {}
		end

		for Position, Path in Direction do
			local X, Y = Path.Row, Path.Column

			-- Check whether the square is a valid, existing square on the board

			if Resources.SquareInBounds({ Row = X, Column = Y }, Chessboard) then
				-- Adds the validated coordinate to the filtered dictionary

				table.insert(Filter[Name], { Row = X, Column = Y })
			end
		end
	end

	-- Returns the filtered dictionary of valid coordinates

	return Filter
end

return Service
