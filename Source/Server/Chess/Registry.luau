local Storage = game:GetService("ReplicatedStorage")
local Server = game:GetService("ServerScriptService")

local Dependencies = Storage.Dependencies
local Packages = Storage.Packages

local Knit = require(Packages.Knit)

local Configuration = require(Dependencies.Configuration)
local Parameters = require(Server.Storage.Parameters)
local Utilities = require(Dependencies.Utilities)

local Cooldown = Configuration.Cooldown
local Default = Configuration.Default

local Service = Knit.CreateService({
	Name = "Registry",

	Client = {
		Disconnect = Knit.CreateSignal(),
	},
})

local Client = Service.Client

local Trajectory = {
	Vertical = {}, -- Forward movement path
	Horizontal = {}, -- Backward movement path

	Left = {}, -- Diagonal movement to the left
	Right = {}, -- Diagonal movement to the right
}

-- Unpacks a square name (e.g. "(2, 3)") into row and column numbers

function Service.Unpack(Square)
	local Row, Column = string.match(Square.Name, "%((%d+),%s*(%d+)%)")

	return tonumber(Row), tonumber(Column)
end

-- Converts given coordinates into a string name (e.g. "(2, 3)") and finds the matching square on the board

function Service:Convert(Coordinates, Chessboard)
	local Row, Column = Coordinates.Row, Coordinates.Column
	local Identifier = string.format("(%d, %d)", Row, Column)

	return Chessboard.Board:FindFirstChild(Identifier)
end

-- Checks whether a given coordinate is within bounds (i.e. exists on the board)

function Service.SquareInBounds(Coordinates, Chessboard)
	return Service:Convert(Coordinates, Chessboard) ~= Default.Null
end

-- Returns the stored piece coordinates from the match's data.

function Service.GetCoordinates(Piece, Name)
	return Parameters.Matches[Name].Pieces[Piece]
end

-- Converts a square to a Vector3 position (likely for piece movement / placement)

function Service.GetSquareVector(Square, Chessboard)
	if Square:IsDescendantOf(Chessboard) then
		return Square.CFrame
	end
end

--[[
	Verifies the selected piece matches the identifier associated with the chessboard. 

	Checks whether the selected piece has access to the target square.
	Upon confirmation, moves the piece to the target square.
]]

function Client:CheckAvailability(Player, Piece, Square)
	local Row, Column = Service.Unpack(Square)

	local Coordinates = Piece:GetAttribute("Coordinates")

	local Name = Piece:GetAttribute("Piece")
	local Identifier = Piece:GetAttribute("Identifier")

	-- Validate that the specified row exists in the board's storage table

	if not Parameters.Matches[Identifier].Storage[Row] then
		return "The specified coordinates are invalid or reference a non-existent board position."
	end

	-- Checks whether the piece is already standing in the same spot

	if table.find({ Parameters.Matches[Identifier].Storage[Row][Column] }, Piece) then
		return "The piece hasn't moved. It's already standing in the same spot"
	end

	-- Reference the current chessboard layout

	local Chessboard = Parameters.Matches[Identifier].Board

	local Path = Client[Name](Client, Player, Piece)

	-- Convert the route into a flat array for easier square validation

	local Route = Service:Compute(Path, Chessboard)

	-- Verify that the intended square is part of the computed valid movement path

	if not table.find(Route, Square) then
		return "Requested square is not part of the authorized path generated by the movement algorithm."
	end

	-- The history log for retaining the chessboard's information

	local Log = Parameters.Logs(Piece, Row, Column, Coordinates, Identifier)

	-- Check whether a piece already exists in the targeted square

	if Parameters.Matches[Identifier].Storage[Row][Column] then
		Log.Capture = Parameters.Capture(Identifier, Row, Column)

		-- Remove the existing piece instance from the board entirely

		Parameters.Matches[Identifier].Storage[Row][Column]:Destroy()
	end

	-- Adds support for logging the move in the piece's history.

	table.insert(Parameters.Matches[Identifier].History, Log)

	-- Update the piece's location in the board's storage structure

	Parameters.Matches[Identifier].Storage[Row][Column] = Piece

	-- Encode the new coordinates into a UDim and assign it to the piece's attributes

	Piece:SetAttribute("Coordinates", Log.To)

	-- Set the piece's movement status to active, enabling logic dependent on prior movement such as castling eligibility or pawn advancement behavior.

	if not Piece:GetAttribute("HasMoved") then
		Piece:SetAttribute("HasMoved", Default.On)
	end

	-- Reset the storage slot to a null placeholder to maintain board integrity

	local Scale, Offset = Coordinates.Scale, Coordinates.Offset

	Parameters.Matches[Identifier].Storage[Scale][Offset] = Default.Null

	-- Update the piece's position in the 3D world to reflect the new board state

	Utilities.Animate(Piece, Configuration.Movement.Animation, {
		Position = Service.GetSquareVector(Square, Chessboard).Position,
	}):Play()

	-- Notify the client of a successful move (or trigger any client-side disconnection logic)

	return Client.Disconnect:Fire(Player)
end

function Client:Rook(Client, Piece)
	local Coordinates = Piece:GetAttribute("Coordinates")

	local Colour = Piece:GetAttribute("Colour")
	local Identifier = Piece:GetAttribute("Identifier")

	-- Column refers to the vertical columns, while Rows refers to the horizontal rows.

	local Rows, Column = Coordinates.Scale, Coordinates.Offset

	local Offsets = {
		Up = { X = 0, Y = 1 }, -- Forwards
		Down = { X = 0, Y = -1 }, -- Backwards

		Right = { X = 1, Y = 0 }, -- Right
		Left = { X = -1, Y = 0 }, -- Left
	}

	local Route = Utilities.CloneDictionary(Trajectory)

	for Name, Direction in Offsets do
		-- Step through a maximum of 7 tiles in that direction (standard chessboard)

		for Step = Default.One, 7, Default.One do
			local X = Rows + Direction.X * Step
			local Y = Column + Direction.Y * Step

			-- Stop when outside the board boundaries

			if not Parameters.Matches[Identifier].Storage[X] then
				break
			end

			-- Get any occupant in the current square

			local Occupant = Parameters.Matches[Identifier].Storage[X][Y]

			if Parameters.Matches[Identifier].Storage[X][Y] then
				-- Stop completely if it's an ally (cannot move or capture)

				if not table.find({ Occupant:GetAttribute("Colour") }, Colour) then
					table.insert(Route[Name], { Row = X, Column = Y })
				end

				break
			end

			-- Add the empty square to the route

			table.insert(Route[Name], { Row = X, Column = Y })
		end
	end

	return Service.Filter(Route, workspace.Matches[Identifier])
end

-- Computes the available path for a pawn piece based on its coordinates and attributes

function Client:Pawn(Client, Piece)
	local Coordinates = Piece:GetAttribute("Coordinates")

	local HasMoved = Piece:GetAttribute("HasMoved")
	local Direction = Piece:GetAttribute("Direction")
	local Identifier = Piece:GetAttribute("Identifier")

	-- Column refers to the vertical columns, while Rows refers to the horizontal rows.

	local Rows, Column = Coordinates.Scale, Coordinates.Offset

	local Route = Utilities.CloneDictionary(Trajectory)

	if not Parameters.Matches[Identifier].Storage[Rows][Column + Direction] then
		table.insert(Route.Vertical, { Row = Rows, Column = Column + Direction })
	end

	-- Checks whether the piece has been already moved before adding double forwards.

	if not HasMoved then
		table.insert(Route.Vertical, { Row = Rows, Column = Column + (Direction * 2) })
	end

	-- Checks whether a square actually exists on the left diagonal relative to the xAxis, yAxis

	if Parameters.Matches[Identifier].Storage[Rows - Direction] then
		-- Checks whether a piece exists on the left diagonal relative to the xAxis, yAxis.

		if Parameters.Matches[Identifier].Storage[Rows - Direction][Column + Direction] then
			table.insert(Route.Horizontal, { Row = Rows - Direction, Column = Column + Direction })
		end
	end

	-- Checks whether the square actually exists on the left diagonal relative to the xAxis, yAxis

	if Parameters.Matches[Identifier].Storage[Rows + Direction] then
		-- Checks whether a piece exists on the right diagonal relative to the xAxis, yAxis.

		if Parameters.Matches[Identifier].Storage[Rows + Direction][Column + Direction] then
			table.insert(Route.Horizontal, { Row = Rows + Direction, Column = Column + Direction })
		end
	end

	--TODO: Add en-passant captures
	--TODO: Add piece promotion

	return Service.Filter(Route, workspace.Matches[Identifier])
end

-- Computes the available path for a pawn piece based on its coordinates and attributes

function Client:King(Client, Piece)
	local Route = Utilities.CloneDictionary(Trajectory)

	local Coordinates = Piece:GetAttribute("Coordinates")
	local Identifier = Piece:GetAttribute("Identifier")
	local Colour = Piece:GetAttribute("Colour")

	-- Column refers to the vertical columns, while Rows refers to the horizontal rows.

	local Row, Column = Coordinates.Scale, Coordinates.Offset

	local Offsets = {
		Horizontal = {
			{ Row = 1, Column = 0 },
			{ Row = -1, Column = 0 },
		}, -- Down, Up

		Vertical = {
			{ Row = 0, Column = 1 },
			{ Row = 0, Column = -1 },
		}, -- Right, Left

		Right = {
			{ Row = 1, Column = 1 },
			{ Row = -1, Column = 1 },
		}, -- Down-right, Down-left

		Left = {
			{ Row = 1, Column = -1 },
			{ Row = -1, Column = -1 },
		}, -- Up-right, Up-left
	}

	for Name, Offset in Offsets do
		for Position, Direction in Offset do
			local X, Y = Direction.Row, Direction.Column

			if not Parameters.Matches[Identifier].Storage[X + Row] then
				continue
			end

			if not Parameters.Matches[Identifier].Storage[X + Row][Column + Y] then
				table.insert(Route[Name], { Row = X + Row, Column = Y + Column })
			end

			if Parameters.Matches[Identifier].Storage[X + Row][Column + Y] then
				local Occupant = Parameters.Matches[Identifier].Storage[X + Row][Column + Y]

				if not table.find({ Occupant:GetAttribute("Colour") }, Colour) then
					table.insert(Route[Name], { Row = X + Row, Column = Y + Column })
				end
			end

			-- Stops scanning in this direction after encountering a piece (cannot jump over pieces).
		end
	end

	--TODO: Implement logic for castling, including king and rook movement validation, path clearance checks, and move execution.

	return Service.Filter(Route, workspace.Matches[Identifier])
end

-- Transforms coordinate-based trajectory paths into square instances on the board

function Service:Compute(Route, Chessboard)
	local Filter = {}

	-- Convert the coordinate into a square instance and assign it under the direction's key

	for Name, Direction in Route do
		for Position, Coordinates in Direction do
			local X, Y = Coordinates.Row, Coordinates.Column

			table.insert(Filter, Service:Convert({ Row = X, Column = Y }, Chessboard))
		end
	end

	-- Returns the dictionary containing square instances per movement direction

	return Filter
end

-- Filters out invalid squares from the given movement trajectory.

function Service.Filter(Trajectory, Chessboard)
	local Filter = {}

	-- Iterates through each individual square path in that direction

	for Name, Direction in Trajectory do
		if not Filter[Name] then
			Filter[Name] = {}
		end

		for Position, Path in Direction do
			local X, Y = Path.Row, Path.Column

			-- Check whether the square is a valid, existing square on the board

			if Service.SquareInBounds({ Row = X, Column = Y }, Chessboard) then
				-- Adds the validated coordinate to the filtered dictionary

				table.insert(Filter[Name], { Row = X, Column = Y })
			end
		end
	end

	-- Returns the filtered dictionary of valid coordinates

	return Filter
end

-- I have no idea what the heck I'm doing, but it seems to be working so... can't really complain!

return Service
