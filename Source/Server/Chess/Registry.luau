local Storage = game:GetService("ReplicatedStorage")
local Server = game:GetService("ServerScriptService")

local Vault = Server.Storage

local Dependencies = Storage.Dependencies
local Packages = Storage.Packages

local Knit = require(Packages.Knit)

local Schema = require(Vault.Schema)
local Utilities = require(Dependencies.Utilities)
local Configuration = require(Dependencies.Configuration)

local Cooldown = Configuration.Cooldown
local Default = Configuration.Default

local Service = Knit.CreateService({
	Name = "Registry",

	Client = {
		Disconnect = Knit.CreateSignal(),
	},
})

local Client = Service.Client

-- Unpacks a square name (e.g. "(2, 3)") into row and column numbers

function Service.Unpack(Square)
	local Row, Column = string.match(Square.Name, "%((%d+),%s*(%d+)%)")

	return tonumber(Row), tonumber(Column)
end

-- Converts given coordinates into a string name (e.g. "(2, 3)") and finds the matching square on the board

function Service:Convert(Coordinates, Chessboard)
	local Row, Column = Coordinates.Row, Coordinates.Column
	local Identifier = string.format("(%d, %d)", Row, Column)

	return Chessboard.Board:FindFirstChild(Identifier)
end

-- Checks whether a given coordinate is within bounds (i.e. exists on the board)

function Service.SquareInBounds(Coordinates, Chessboard)
	return Service:Convert(Coordinates, Chessboard) ~= Default.Null
end

-- Returns the stored piece coordinates from the match's data.

function Service.GetCoordinates(Piece, Name)
	return Schema.Matches[Name].Pieces[Piece]
end

-- Converts a square to a Vector3 position (likely for piece movement / placement)

function Service.GetSquareVector(Square, Chessboard)
	if Square:IsDescendantOf(Chessboard) then
		return Square.CFrame
	end
end

--[[
	Verifies the selected piece matches the identifier associated with the chessboard. 

	Checks whether the selected piece has access to the target square.
	Upon confirmation, moves the piece to the target square.
]]

function Client:CheckAvailability(Player, Piece, Square)
	local Row, Column = Service.Unpack(Square)

	local Coordinates = Piece:GetAttribute("Coordinates")

	local Name = Piece:GetAttribute("Piece")
	local Identifier = Piece:GetAttribute("Identifier")

	-- Validate that the specified row exists in the board's storage table

	if not Schema.Matches[Identifier].Storage[Row] then
		return "The specified coordinates are invalid or reference a non-existent board position."
	end

	-- Checks whether the piece is already standing in the same spot

	if table.find({ Schema.Matches[Identifier].Storage[Row][Column] }, Piece) then
		return "The piece hasn't moved. It's already standing in the same spot"
	end

	-- Reference the current chessboard layout

	local Chessboard = Schema.Matches[Identifier].Board

	local Path = Client[Name](Client, Player, Piece)

	-- Convert the route into a flat array for easier square validation

	local Route = Service:Compute(Path, Chessboard)

	-- Verify that the intended square is part of the computed valid movement path

	if not table.find(Route, Square) then
		return "Requested square is not part of the authorized path generated by the movement algorithm."
	end

	local X, Y = Coordinates.Scale, Coordinates.Offset

	-- The history log for retaining the chessboard's information

	local Log = {
		Piece = Piece:GetAttribute("Piece"), -- The type of piece (e.g., Rook, Pawn)
		Colour = Piece:GetAttribute("Colour"), -- The colour (e.g., White, Black)

		To = UDim.new(Row, Column), -- Destination square (as a UDim)
		From = UDim.new(X, Y), -- Starting square (as a UDim)

		Timestamp = os.clock(), -- Time of move (in seconds since session start)

		-- Add Move No. and additional configurations
	}

	-- Check whether a piece already exists in the targeted square

	if Schema.Matches[Identifier].Storage[Row][Column] then
		local Object = Schema.Matches[Identifier].Storage[Row][Column]

		Log.Capture = {
			Piece = Object:GetAttribute("Piece"), -- Captured piece type
			Colour = Object:GetAttribute("Colour"), -- Captured piece colour

			Coordinates = Object:GetAttribute("Coordinates"), -- Position at capture
		}

		-- Remove the existing piece instance from the board entirely

		Schema.Matches[Identifier].Storage[Row][Column]:Destroy()
	end

	-- Adds support for logging the move in the piece's history.

	table.insert(Schema.Matches[Identifier].History, Log)

	-- Update the piece's location in the board's storage structure

	Schema.Matches[Identifier].Storage[Row][Column] = Piece

	-- Encode the new coordinates into a UDim and assign it to the piece's attributes

	Piece:SetAttribute("Coordinates", Log.To)

	-- Set the piece's movement status to active, enabling logic dependent on prior movement such as castling eligibility or pawn advancement behavior.

	if not Piece:GetAttribute("HasMoved") then
		Piece:SetAttribute("HasMoved", Default.On)
	end

	-- Reset the storage slot to a null placeholder to maintain board integrity

	local Scale, Offset = Coordinates.Scale, Coordinates.Offset

	Schema.Matches[Identifier].Storage[Scale][Offset] = Default.Null

	-- Update the piece's position in the 3D world to reflect the new board state

	Utilities.Animate(Piece, Configuration.Movement.Animation, {
		Position = Service.GetSquareVector(Square, Chessboard).Position,
	}):Play()

	-- Notify the client of a successful move (or trigger any client-side disconnection logic)

	return Client.Disconnect:Fire(Player)
end

function Client:Rook(Client, Piece)
	local Coordinates = Piece:GetAttribute("Coordinates")

	local Colour = Piece:GetAttribute("Colour")
	local Identifier = Piece:GetAttribute("Identifier")

	-- Column refers to the vertical columns, while Rows refers to the horizontal rows.

	local Rows, Column = Coordinates.Scale, Coordinates.Offset

	local Offsets = {
		Vertical = {
			Up = { X = 0, Y = 1 }, -- Forwards
			Down = { X = 0, Y = -1 }, -- Backwards
		},

		Horizontal = {
			Right = { X = 1, Y = 0 }, -- Right
			Left = { X = -1, Y = 0 }, -- Left
		},
	}

	local Route = Utilities.CloneDictionary(Schema.Trajectory)

	for Path, Direction in Offsets do
		-- Step through a maximum of 7 tiles in that direction (standard chessboard)

		for Name, Offset in Direction do
			for Step = Default.One, 7, Default.One do
				local X = Rows + Offset.X * Step
				local Y = Column + Offset.Y * Step

				-- Stop when outside the board boundaries

				if not Schema.Matches[Identifier].Storage[X] then
					break
				end

				-- Get any occupant in the current square

				local Occupant = Schema.Matches[Identifier].Storage[X][Y]

				if Schema.Matches[Identifier].Storage[X][Y] then
					-- Stop completely if it's an ally (cannot move or capture)

					if not table.find({ Occupant:GetAttribute("Colour") }, Colour) then
						table.insert(Route[Path], { Row = X, Column = Y })
					end

					break
				end

				-- Add the empty square to the route

				table.insert(Route[Path], { Row = X, Column = Y })
			end
		end
	end

	return Service.Filter(Route, workspace.Matches[Identifier])
end

-- Computes the available path for a pawn piece based on its coordinates and attributes

function Client:Pawn(Client, Piece)
	local Coordinates = Piece:GetAttribute("Coordinates")

	local Colour = Piece:GetAttribute("Colour")
	local HasMoved = Piece:GetAttribute("HasMoved")
	local Direction = Piece:GetAttribute("Direction")
	local Identifier = Piece:GetAttribute("Identifier")

	-- Column refers to the vertical columns, while Rows refers to the horizontal rows.

	local Rows, Column = Coordinates.Scale, Coordinates.Offset

	local Route = Utilities.CloneDictionary(Schema.Trajectory)

	if not Schema.Matches[Identifier].Storage[Rows][Column + Direction] then
		table.insert(Route.Vertical, { Row = Rows, Column = Column + Direction })
	end

	-- Checks whether the piece has been already moved before adding double forwards.

	if not HasMoved then
		table.insert(Route.Vertical, { Row = Rows, Column = Column + (Direction * 2) })
	end

	-- Checks whether a square actually exists on the left diagonal relative to the xAxis, yAxis

	if Schema.Matches[Identifier].Storage[Rows - Direction] then
		-- Checks whether a piece exists on the left diagonal relative to the xAxis, yAxis

		local xAxis, yAxis = Rows - Direction, Column + Direction

		if Schema.Matches[Identifier].Storage[Rows - Direction][Column + Direction] then
			local Occupant = Schema.Matches[Identifier].Storage[xAxis][yAxis]

			if not table.find({ Occupant:GetAttribute("Colour") }, Colour) then
				table.insert(Route.Horizontal, { Row = xAxis, Column = yAxis })
			end
		end
	end

	-- Checks whether the square actually exists on the left diagonal relative to the xAxis, yAxis

	if Schema.Matches[Identifier].Storage[Rows + Direction] then
		-- Checks whether a piece exists on the right diagonal relative to the xAxis, yAxis.

		local xAxis, yAxis = Rows + Direction, Column + Direction

		if Schema.Matches[Identifier].Storage[Rows + Direction][Column + Direction] then
			local Occupant = Schema.Matches[Identifier].Storage[Rows + Direction][Column + Direction]

			if not table.find({ Occupant:GetAttribute("Colour") }, Colour) then
				table.insert(Route.Horizontal, { Row = xAxis, Column = yAxis })
			end
		end
	end

	--TODO: Add en-passant captures ability & pawn promotion

	return Service.Filter(Route, workspace.Matches[Identifier])
end

-- Computes the available path for a pawn piece based on its coordinates and attributes

function Client:Bishop(Client, Piece)
	local Route = Utilities.CloneDictionary(Schema.Trajectory)

	local Colour = Piece:GetAttribute("Colour")
	local Identifier = Piece:GetAttribute("Identifier")
	local Coordinates = Piece:GetAttribute("Coordinates")

	local Row, Column = Coordinates.Scale, Coordinates.Offset

	local Offsets = {
		Right = {
			Up = { X = 1, Y = 1 }, -- Right-up
			Down = { X = 1, Y = -1 }, -- Right-down
		},

		Left = {
			Up = { X = -1, Y = 1 }, -- Left-up
			Down = { X = -1, Y = -1 }, -- Left-down
		},
	}

	for Name, Direction in Offsets do
		-- Iterates over each diagonal group (Left and Right)

		for Path, Offset in Direction do
			-- Steps outward along the diagonal up to 7 tiles
			for Step = Default.One, 7, Default.One do
				local X = Offset.X * Step
				local Y = Offset.Y * Step

				-- Skips any rows that are outside the board boundaries

				if not Schema.Matches[Identifier].Storage[X + Row] then
					continue
				end

				-- Inserts empty board squares into the movement route

				if not Schema.Matches[Identifier].Storage[X + Row][Column + Y] then
					table.insert(Route[Name], { Row = X + Row, Column = Y + Column })
				elseif Schema.Matches[Identifier].Storage[X + Row][Column + Y] then
					local Occupant = Schema.Matches[Identifier].Storage[X + Row][Column + Y]

					-- Appends enemy-occupied squares as valid capture targets

					if not table.find({ Occupant:GetAttribute("Colour") }, Colour) then
						table.insert(Route[Name], { Row = X + Row, Column = Y + Column })
					end

					-- Ends path traversal after encountering any occupant

					break
				end
			end

			-- Completes traversal for the current diagonal direction
		end
	end

	return Service.Filter(Route, workspace.Matches[Identifier])
end

-- Computes the available path for a Knight piece based on its coordinates and attributes

function Client:Knight(Client, Piece)
	local Route = Utilities.CloneDictionary(Schema.Trajectory)

	local Colour = Piece:GetAttribute("Colour")
	local Identifier = Piece:GetAttribute("Identifier")
	local Coordinates = Piece:GetAttribute("Coordinates")

	local Row, Column = Coordinates.Scale, Coordinates.Offset

	local Offsets = {
		Right = {
			Up = { X = 1, Y = 2 }, -- Right-up
			Down = { X = 1, Y = -2 }, -- Right-down

			Left = { X = 2, Y = 1 },
			Right = { X = 2, Y = -1 },
		},

		Left = {
			Up = { X = -1, Y = 2 }, -- Left-up
			Down = { X = -1, Y = -2 }, -- Left-down

			Left = { X = -2, Y = -1 }, -- Left-left
			Right = { X = -2, Y = 1 },
		},
	}

	for Name, Direction in Offsets do
		-- Iterate through each L-shaped offset

		for Path, Offset in Direction do
			local X, Y = Offset.X, Offset.Y

			-- Skips the invalid rows (Off-board)

			if not Schema.Matches[Identifier].Storage[X + Row] then
				continue
			end

			-- Adds the square after verifying that it's empty.

			if not Schema.Matches[Identifier].Storage[X + Row][Column + Y] then
				table.insert(Route[Name], { Row = X + Row, Column = Y + Column })
			elseif Schema.Matches[Identifier].Storage[X + Row][Column + Y] then
				local Occupant = Schema.Matches[Identifier].Storage[X + Row][Column + Y]

				-- Capture enemy piece only (allies are ignored)

				if not table.find({ Occupant:GetAttribute("Colour") }, Colour) then
					table.insert(Route[Name], { Row = X + Row, Column = Y + Column })
				end
			end

			-- No break here — Knights don’t scan beyond pieces.
		end
	end

	return Service.Filter(Route, workspace.Matches[Identifier])
end

-- Computes the available path for a pawn piece based on its coordinates and attributes

function Client:Queen(Client, Piece)
	local Route = Utilities.CloneDictionary(Schema.Trajectory)

	local Colour = Piece:GetAttribute("Colour")
	local Identifier = Piece:GetAttribute("Identifier")
	local Coordinates = Piece:GetAttribute("Coordinates")

	local Row, Column = Coordinates.Scale, Coordinates.Offset

	local Offsets = {
		Horizontal = {
			{ X = 1, Y = 0 },
			{ X = -1, Y = 0 },
		}, -- Down, Up

		Vertical = {
			{ X = 0, Y = 1 },
			{ X = 0, Y = -1 },
		}, -- Right, Left

		Right = {
			Up = { X = 1, Y = 1 }, -- Right-up
			Down = { X = 1, Y = -1 }, -- Right-down
		},

		Left = {
			Up = { X = -1, Y = 1 }, -- Left-up
			Down = { X = -1, Y = -1 }, -- Left-down
		},
	}

	for Name, Direction in Offsets do
		-- Iterates over each diagonal group (Left and Right)

		for Path, Offset in Direction do
			-- Steps outward along the diagonal up to 7 tiles
			for Step = Default.One, 7, Default.One do
				local X = Offset.X * Step
				local Y = Offset.Y * Step

				-- Skips rows that are outside the board boundaries
				if not Schema.Matches[Identifier].Storage[X + Row] then
					continue
				end

				-- Inserts empty board squares into the movement route
				if not Schema.Matches[Identifier].Storage[X + Row][Column + Y] then
					table.insert(Route[Name], { Row = X + Row, Column = Y + Column })
				elseif Schema.Matches[Identifier].Storage[X + Row][Column + Y] then
					local Occupant = Schema.Matches[Identifier].Storage[X + Row][Column + Y]

					-- Appends enemy-occupied squares as valid capture targets
					if not table.find({ Occupant:GetAttribute("Colour") }, Colour) then
						table.insert(Route[Name], { Row = X + Row, Column = Y + Column })
					end

					-- Ends path traversal after encountering any occupant
					break
				end
			end

			-- Completes traversal for the current diagonal direction
		end
	end

	return Service.Filter(Route, workspace.Matches[Identifier])
end

-- Computes the available path for a pawn piece based on its coordinates and attributes

function Client:King(Client, Piece)
	local Route = Utilities.CloneDictionary(Schema.Trajectory)

	local Coordinates = Piece:GetAttribute("Coordinates")
	local Identifier = Piece:GetAttribute("Identifier")
	local Colour = Piece:GetAttribute("Colour")

	-- Column refers to the vertical columns, while Rows refers to the horizontal rows.

	local Row, Column = Coordinates.Scale, Coordinates.Offset

	local Offsets = {
		Horizontal = {
			{ X = 1, Y = 0 },
			{ X = -1, Y = 0 },
		}, -- Down, Up

		Vertical = {
			{ X = 0, Y = 1 },
			{ X = 0, Y = -1 },
		}, -- Right, Left

		Right = {
			{ X = 1, Y = 1 },
			{ X = -1, Y = 1 },
		}, -- Down-right, Down-left

		Left = {
			{ X = 1, Y = -1 },
			{ X = -1, Y = -1 },
		}, -- Up-right, Up-left
	}

	for Name, Offset in Offsets do
		for Position, Direction in Offset do
			local X, Y = Direction.X, Direction.Y

			if not Schema.Matches[Identifier].Storage[X + Row] then
				continue
			end

			if not Schema.Matches[Identifier].Storage[X + Row][Column + Y] then
				table.insert(Route[Name], { Row = X + Row, Column = Y + Column })
			end

			if Schema.Matches[Identifier].Storage[X + Row][Column + Y] then
				local Occupant = Schema.Matches[Identifier].Storage[X + Row][Column + Y]

				if not table.find({ Occupant:GetAttribute("Colour") }, Colour) then
					table.insert(Route[Name], { Row = X + Row, Column = Y + Column })
				end
			end

			-- Stops scanning in this direction after encountering a piece (cannot jump over pieces).
		end
	end

	--TODO: Implement logic for castling, including king and rook movement validation, path clearance checks, and move execution.

	return Service.Filter(Route, workspace.Matches[Identifier])
end

-- Transforms coordinate-based trajectory paths into square instances on the board

function Service:Compute(Route, Chessboard)
	local Filter = {}

	-- Convert the coordinate into a square instance and assign it under the direction's key

	for Name, Direction in Route do
		for Position, Coordinates in Direction do
			local X, Y = Coordinates.Row, Coordinates.Column

			table.insert(Filter, Service:Convert({ Row = X, Column = Y }, Chessboard))
		end
	end

	-- Returns the dictionary containing square instances per movement direction

	return Filter
end

-- Filters out invalid squares from the given movement trajectory.

function Service.Filter(Trajectory, Chessboard)
	local Filter = {}

	-- Iterates through each individual square path in that direction

	for Name, Direction in Trajectory do
		if not Filter[Name] then
			Filter[Name] = {}
		end

		for Position, Path in Direction do
			local X, Y = Path.Row, Path.Column

			-- Check whether the square is a valid, existing square on the board

			if Service.SquareInBounds({ Row = X, Column = Y }, Chessboard) then
				-- Adds the validated coordinate to the filtered dictionary

				table.insert(Filter[Name], { Row = X, Column = Y })
			end
		end
	end

	-- Returns the filtered dictionary of valid coordinates

	return Filter
end

-- I have no idea what the heck I'm doing, but it seems to be working so... can't really complain!

return Service
